<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlindChess 3D - Ethereal Sanctum</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f4f8;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #1e2b39;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 10;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 300;
        }

        #status {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #1e2b39;
            font-family: 'Inter', sans-serif;
            font-size: 1.2em;
            pointer-events: none;
            font-weight: bold;
        }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>BlindChess 3D</h1>
    </div>
    <div id="status">White's Turn - Select a piece</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Game State ---
        let selectedPiece = null;
        let currentTurn = 'white';
        const pieces = []; // Array to store piece objects
        const squares = []; // Array to store square meshes

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f7fa);
        scene.fog = new THREE.Fog(0xf5f7fa, 10, 50);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 16, 16);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const rimLight = new THREE.SpotLight(0x44aaff, 5);
        rimLight.position.set(-10, 5, -10);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);

        // --- Materials ---
        const darkPieceMat = new THREE.MeshPhysicalMaterial({
            color: 0x1e2b39, roughness: 0.2, metalness: 0.1, clearcoat: 0.5
        });
        const whitePieceMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, roughness: 0.1, metalness: 0.0, transmission: 0.05, thickness: 0.5
        });
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, thickness: 1.0, transparent: true, opacity: 1.0
        });
        const highlightMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false
        });

        // --- Geometry ---
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Platform
        const platform = new THREE.Mesh(new THREE.CylinderGeometry(9, 8, 0.5, 64), glassMat);
        platform.position.y = -0.5;
        platform.receiveShadow = true;
        mainGroup.add(platform);

        const ring = new THREE.Mesh(new THREE.TorusGeometry(8.2, 0.05, 16, 100), new THREE.MeshBasicMaterial({ color: 0x00aaff }));
        ring.rotation.x = Math.PI / 2;
        ring.position.y = -0.5;
        mainGroup.add(ring);

        // Board
        const boardGroup = new THREE.Group();
        const squareSize = 1.4;
        const boardSize = 8 * squareSize;
        const offset = (boardSize - squareSize) / 2;

        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const isDark = (x + z) % 2 === 1;
                const geometry = new THREE.BoxGeometry(squareSize * 0.95, 0.2, squareSize * 0.95);
                const material = isDark ? darkPieceMat : whitePieceMat;
                const square = new THREE.Mesh(geometry, material);

                // Store grid coordinates in userData for logic
                square.userData = { type: 'square', gridX: x, gridZ: z };

                square.position.set(x * squareSize - offset, 0, z * squareSize - offset);
                square.receiveShadow = true;
                square.castShadow = true;
                boardGroup.add(square);
                squares.push(square);
            }
        }
        mainGroup.add(boardGroup);

        // Decor
        const decorGroup = new THREE.Group();
        const geoShape = new THREE.IcosahedronGeometry(0.3, 0);
        const geoMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.2, emissive: 0x0044aa, emissiveIntensity: 0.2 });
        for (let i = 0; i < 12; i++) {
            const mesh = new THREE.Mesh(geoShape, geoMat);
            const angle = (i / 12) * Math.PI * 2;
            const radius = 10;
            mesh.position.set(Math.cos(angle) * radius, Math.random() * 4 - 2, Math.sin(angle) * radius);
            decorGroup.add(mesh);
        }
        mainGroup.add(decorGroup);

        // --- Pieces ---
        function createPiece(type, color) {
            const group = new THREE.Group();
            const material = color === 'white' ? whitePieceMat : darkPieceMat;

            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 0.2, 32), material);
            base.position.y = 0.1;
            group.add(base);

            // Simple geometry per type
            let body;
            if (type === 'pawn') {
                body = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.8, 32), material);
                body.position.y = 0.6;
                group.add(body);
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), material);
                head.position.y = 0.9;
                group.add(head);
            } else if (type === 'rook') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.8, 32), material);
                body.position.y = 0.6;
                group.add(body);
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.3, 6), material);
                top.position.y = 1.1;
                group.add(top);
            } else if (type === 'knight') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.6, 32), material);
                body.position.y = 0.5;
                group.add(body);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.6), material);
                head.position.set(0, 1.0, 0.1);
                head.rotation.x = -0.2;
                group.add(head);
            } else if (type === 'bishop') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.0, 32), material);
                body.position.y = 0.7;
                group.add(body);
                const head = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.4, 4, 8), material);
                head.position.y = 1.3;
                group.add(head);
            } else if (type === 'queen') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.45, 1.4, 32), material);
                body.position.y = 0.9;
                group.add(body);
                const crown = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 16, 100), material);
                crown.rotation.x = Math.PI / 2;
                crown.position.y = 1.6;
                group.add(crown);
            } else if (type === 'king') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 1.5, 32), material);
                body.position.y = 0.95;
                group.add(body);
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), material);
                crossV.position.y = 1.8;
                group.add(crossV);
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.1), material);
                crossH.position.y = 1.8;
                group.add(crossH);
            }

            group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });

            // Metadata for logic
            group.userData = { type: 'piece', pieceType: type, color: color };
            return group;
        }

        const backRank = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

        function spawnPiece(type, color, gridX, gridZ) {
            const piece = createPiece(type, color);
            const worldX = gridX * squareSize - offset;
            const worldZ = gridZ * squareSize - offset;
            piece.position.set(worldX, 0.1, worldZ);

            // Store current grid position
            piece.userData.gridX = gridX;
            piece.userData.gridZ = gridZ;

            boardGroup.add(piece);
            pieces.push(piece);
        }

        // Spawn Initial Pieces
        for (let i = 0; i < 8; i++) {
            spawnPiece(backRank[i], 'white', i, 0);
            spawnPiece('pawn', 'white', i, 1);
            spawnPiece(backRank[i], 'black', i, 7);
            spawnPiece('pawn', 'black', i, 6);
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let highlightSquare = null;

        // Create a highlight marker
        const markerGeo = new THREE.PlaneGeometry(squareSize, squareSize);
        markerGeo.rotateX(-Math.PI / 2);
        const marker = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 }));
        marker.position.y = 0.11;
        marker.visible = false;
        boardGroup.add(marker);

        // Selection Ring
        const selectRing = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide }));
        selectRing.rotation.x = -Math.PI / 2;
        selectRing.position.y = 0.12;
        selectRing.visible = false;
        boardGroup.add(selectRing);

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);

        function onPointerMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Hover effect
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(squares);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                marker.position.x = hit.position.x;
                marker.position.z = hit.position.z;
                marker.visible = true;
            } else {
                marker.visible = false;
            }
        }

        function onPointerDown(event) {
            raycaster.setFromCamera(mouse, camera);

            // 1. Check for Piece Click
            // We raycast against the boardGroup children (pieces are groups of meshes)
            // But raycaster hits meshes. We need to find the parent group.
            const intersects = raycaster.intersectObjects(boardGroup.children, true);

            let clickedPiece = null;
            let clickedSquare = null;

            for (let hit of intersects) {
                // Traverse up to find if we hit a piece group
                let obj = hit.object;
                while (obj.parent && obj.parent !== boardGroup) {
                    obj = obj.parent;
                }

                if (obj.userData.type === 'piece') {
                    clickedPiece = obj;
                    break; // Prioritize piece
                } else if (obj.userData.type === 'square') {
                    clickedSquare = obj;
                }
            }

            if (clickedPiece) {
                // Logic: Select only own color
                if (clickedPiece.userData.color === currentTurn) {
                    selectPiece(clickedPiece);
                } else if (selectedPiece) {
                    // Capture attempt?
                    // For now, simple move-to-capture logic
                    movePieceTo(selectedPiece, clickedPiece.position.x, clickedPiece.position.z);
                    // Remove captured piece
                    boardGroup.remove(clickedPiece);
                    pieces.splice(pieces.indexOf(clickedPiece), 1);
                }
            } else if (clickedSquare && selectedPiece) {
                // Move logic
                movePieceTo(selectedPiece, clickedSquare.position.x, clickedSquare.position.z);
            }
        }

        function selectPiece(piece) {
            selectedPiece = piece;
            selectRing.position.x = piece.position.x;
            selectRing.position.z = piece.position.z;
            selectRing.visible = true;

            // Optional: Lift piece slightly
            // piece.position.y = 0.5;
        }

        function movePieceTo(piece, x, z) {
            // Animate move (simple lerp in animate loop or just set for now)
            // Let's just set it for responsiveness
            piece.position.x = x;
            piece.position.z = z;

            // Update selection ring
            selectRing.visible = false;
            selectedPiece = null;

            // Switch turn
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            document.getElementById('status').innerText =
                currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1) + "'s Turn";
        }

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            mainGroup.position.y = Math.sin(time * 0.5) * 0.2;
            decorGroup.rotation.y = time * 0.05;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>