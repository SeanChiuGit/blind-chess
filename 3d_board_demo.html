<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlindChess 3D - Ethereal Sanctum</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f4f8;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #1e2b39;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 10;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 300;
        }

        #status {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #1e2b39;
            font-family: 'Inter', sans-serif;
            font-size: 1.2em;
            pointer-events: none;
            font-weight: bold;
        }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>BlindChess 3D</h1>
    </div>
    <div id="status">White's Turn - Select a piece</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Game State ---
        let selectedPiece = null;
        let currentTurn = 'white';
        const pieces = []; // Array to store piece objects
        const squares = []; // Array to store square meshes

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f7fa);
        scene.fog = new THREE.Fog(0xf5f7fa, 10, 50);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 16, 16);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;

        // --- Materials (Glass Style) ---

        // Dark Glass (Deep Blue - Lightened for visibility)
        const darkPieceMat = new THREE.MeshPhysicalMaterial({
            color: 0x3a5a7a,    // Lighter Blue-Grey
            metalness: 0.1,
            roughness: 0.05,
            transmission: 0.8,
            thickness: 1.5,
            ior: 1.5,
            clearcoat: 1.0,
            attenuationColor: new THREE.Color(0x557799),
            attenuationDistance: 3.0
        });

        // White Glass (Frosted/Clear)
        const whitePieceMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.1,
            transmission: 0.9,
            thickness: 1.5,
            ior: 1.5,
            clearcoat: 1.0,
            attenuationColor: new THREE.Color(0xffffff),
            attenuationDistance: 5.0
        });

        // Board Materials (Keep opaque for contrast)
        const darkBoardMat = new THREE.MeshPhysicalMaterial({
            color: 0x1e2b39, roughness: 0.2, metalness: 0.1, clearcoat: 0.5
        });
        const whiteBoardMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, roughness: 0.1, metalness: 0.0, transmission: 0.05, thickness: 0.5
        });

        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, thickness: 1.0, transparent: true, opacity: 1.0
        });

        // --- Geometry ---
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Platform
        const platform = new THREE.Mesh(new THREE.CylinderGeometry(9, 8, 0.5, 64), glassMat);
        platform.position.y = -0.5;
        platform.receiveShadow = true;
        mainGroup.add(platform);

        const ring = new THREE.Mesh(new THREE.TorusGeometry(8.2, 0.05, 16, 100), new THREE.MeshBasicMaterial({ color: 0x00aaff }));
        ring.rotation.x = Math.PI / 2;
        ring.position.y = -0.5;
        mainGroup.add(ring);

        // Board
        const boardGroup = new THREE.Group();
        const squareSize = 1.4;
        const boardSize = 8 * squareSize;
        const offset = (boardSize - squareSize) / 2;

        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const isDark = (x + z) % 2 === 1;
                const geometry = new THREE.BoxGeometry(squareSize * 0.95, 0.2, squareSize * 0.95);
                const material = isDark ? darkBoardMat : whiteBoardMat;
                const square = new THREE.Mesh(geometry, material);

                // Store grid coordinates in userData for logic
                square.userData = { type: 'square', gridX: x, gridZ: z };

                square.position.set(x * squareSize - offset, 0, z * squareSize - offset);
                square.receiveShadow = true;
                square.castShadow = true;
                boardGroup.add(square);
                squares.push(square);
            }
        }
        mainGroup.add(boardGroup);

        // Decor
        const decorGroup = new THREE.Group();
        const geoShape = new THREE.IcosahedronGeometry(0.3, 0);
        const geoMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.2, emissive: 0x0044aa, emissiveIntensity: 0.2 });
        for (let i = 0; i < 12; i++) {
            const mesh = new THREE.Mesh(geoShape, geoMat);
            const angle = (i / 12) * Math.PI * 2;
            const radius = 10;
            mesh.position.set(Math.cos(angle) * radius, Math.random() * 4 - 2, Math.sin(angle) * radius);
            decorGroup.add(mesh);
        }
        mainGroup.add(decorGroup);

        // --- Question Mark Model ---
        function createQuestionMark() {
            const group = new THREE.Group();
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffd700, // Gold
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xaa6600,
                emissiveIntensity: 0.2
            });

            // Top Curve (Torus segment)
            const curve = new THREE.TorusGeometry(0.3, 0.1, 16, 32, Math.PI * 1.5);
            const curveMesh = new THREE.Mesh(curve, material);
            curveMesh.rotation.z = Math.PI / 4;
            curveMesh.position.set(0, 0.8, 0);
            group.add(curveMesh);

            // Vertical Stem
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.05, 0.4, 16), material);
            stem.position.set(0, 0.5, 0);
            group.add(stem);

            // Dot
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), material);
            dot.position.set(0, 0.15, 0);
            group.add(dot);

            // Floating Animation Helper
            group.userData.isFloating = true;

            return group;
        }

        // --- Detailed Pieces ---
        function createPiece(type, color) {
            if (type === 'hidden') {
                const qMark = createQuestionMark();
                qMark.userData = { type: 'piece', pieceType: 'hidden', color: color };
                return qMark;
            }

            const group = new THREE.Group();
            const material = color === 'white' ? whitePieceMat : darkPieceMat;

            // Common Base for all pieces
            const baseGeo = new THREE.CylinderGeometry(0.45, 0.5, 0.15, 32);
            const base = new THREE.Mesh(baseGeo, material);
            base.position.y = 0.075;
            group.add(base);

            // Helper to add parts
            function addPart(geometry, y, scale = 1) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = y;
                mesh.scale.setScalar(scale);
                group.add(mesh);
                return mesh;
            }

            if (type === 'pawn') {
                // Tapered body
                addPart(new THREE.CylinderGeometry(0.15, 0.35, 0.6, 16), 0.45);
                // Collar
                addPart(new THREE.TorusGeometry(0.15, 0.05, 16, 32), 0.75).rotation.x = Math.PI / 2;
                // Head
                addPart(new THREE.SphereGeometry(0.25, 32, 32), 0.95);

            } else if (type === 'rook') {
                // Column
                addPart(new THREE.CylinderGeometry(0.35, 0.4, 0.8, 32), 0.55);
                // Top rim
                addPart(new THREE.CylinderGeometry(0.45, 0.35, 0.3, 32), 1.05);
                // Crenellations (4 blocks)
                for (let i = 0; i < 4; i++) {
                    const block = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), material);
                    block.position.y = 1.25;
                    const angle = (i / 4) * Math.PI * 2;
                    block.position.x = Math.cos(angle) * 0.25;
                    block.position.z = Math.sin(angle) * 0.25;
                    group.add(block);
                }

            } else if (type === 'knight') {
                // Base stand
                addPart(new THREE.CylinderGeometry(0.3, 0.4, 0.4, 32), 0.35);

                // Horse Head Shape (Extruded)
                const shape = new THREE.Shape();
                shape.moveTo(0, 0);
                shape.lineTo(0.2, 0.1); // nose bottom
                shape.lineTo(0.25, 0.3); // nose tip
                shape.lineTo(0.15, 0.5); // forehead
                shape.lineTo(0.1, 0.7); // ear tip
                shape.lineTo(0, 0.6); // ear base
                shape.lineTo(-0.15, 0.4); // neck back
                shape.lineTo(-0.2, 0); // neck base
                shape.lineTo(0, 0);

                const extrudeSettings = { depth: 0.2, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 };
                const headGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const head = new THREE.Mesh(headGeo, material);
                head.position.set(0, 0.55, -0.1);
                head.rotation.y = color === 'white' ? Math.PI / 2 : -Math.PI / 2; // Face opponent
                // Center the extrusion
                head.geometry.center();
                // Adjust position after centering
                head.position.y = 0.9;
                group.add(head);

            } else if (type === 'bishop') {
                // Tall body
                addPart(new THREE.CylinderGeometry(0.15, 0.35, 0.9, 32), 0.6);
                // Collar
                addPart(new THREE.TorusGeometry(0.2, 0.05, 16, 32), 1.05).rotation.x = Math.PI / 2;
                // Mitre Head
                const head = addPart(new THREE.SphereGeometry(0.25, 32, 32), 1.25);
                head.scale.set(0.8, 1.2, 0.8);
                // Small ball on top
                addPart(new THREE.SphereGeometry(0.08, 16, 16), 1.6);

            } else if (type === 'queen') {
                // Body
                addPart(new THREE.CylinderGeometry(0.2, 0.4, 1.2, 32), 0.75);
                // Collar
                addPart(new THREE.TorusGeometry(0.25, 0.05, 16, 32), 1.35).rotation.x = Math.PI / 2;
                // Crown
                const crown = addPart(new THREE.CylinderGeometry(0.3, 0.15, 0.3, 16), 1.5);
                // Crown points
                const points = addPart(new THREE.TorusGeometry(0.25, 0.05, 16, 6), 1.65);
                points.rotation.x = Math.PI / 2;
                // Top ball
                addPart(new THREE.SphereGeometry(0.15, 32, 32), 1.7);

            } else if (type === 'king') {
                // Body
                addPart(new THREE.CylinderGeometry(0.25, 0.45, 1.3, 32), 0.8);
                // Collar
                addPart(new THREE.TorusGeometry(0.25, 0.08, 16, 32), 1.45).rotation.x = Math.PI / 2;
                // Top Flare
                addPart(new THREE.CylinderGeometry(0.35, 0.2, 0.2, 32), 1.6);
                // Cross
                const v = addPart(new THREE.BoxGeometry(0.1, 0.35, 0.1), 1.9);
                const h = addPart(new THREE.BoxGeometry(0.3, 0.1, 0.1), 1.95);
            }

            group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });

            // Metadata for logic
            group.userData = { type: 'piece', pieceType: type, color: color };
            return group;
        }

        const backRank = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

        function spawnPiece(type, color, gridX, gridZ) {
            // DEMO LOGIC: Make opponent pieces 'hidden' (Question Marks)
            const actualType = color === 'white' ? type : 'hidden';

            const piece = createPiece(actualType, color);
            const worldX = gridX * squareSize - offset;
            const worldZ = gridZ * squareSize - offset;
            piece.position.set(worldX, 0.1, worldZ);

            // Store current grid position
            piece.userData.gridX = gridX;
            piece.userData.gridZ = gridZ;
            piece.userData.realType = type; // Store real type for guessing logic

            boardGroup.add(piece);
            pieces.push(piece);
        }

        // Spawn Initial Pieces
        for (let i = 0; i < 8; i++) {
            spawnPiece(backRank[i], 'white', i, 0);
            spawnPiece('pawn', 'white', i, 1);
            spawnPiece(backRank[i], 'black', i, 7);
            spawnPiece('pawn', 'black', i, 6);
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let highlightSquare = null;

        // Create a highlight marker
        const markerGeo = new THREE.PlaneGeometry(squareSize, squareSize);
        markerGeo.rotateX(-Math.PI / 2);
        const marker = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 }));
        marker.position.y = 0.11;
        marker.visible = false;
        boardGroup.add(marker);

        // Selection Ring
        const selectRing = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide }));
        selectRing.rotation.x = -Math.PI / 2;
        selectRing.position.y = 0.12;
        selectRing.visible = false;
        boardGroup.add(selectRing);

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);

        function onPointerMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Hover effect
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(squares);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                marker.position.x = hit.position.x;
                marker.position.z = hit.position.z;
                marker.visible = true;
            } else {
                marker.visible = false;
            }
        }

        function onPointerDown(event) {
            raycaster.setFromCamera(mouse, camera);

            // 1. Check for Piece Click
            const intersects = raycaster.intersectObjects(boardGroup.children, true);

            let clickedPiece = null;
            let clickedSquare = null;

            for (let hit of intersects) {
                let obj = hit.object;
                while (obj.parent && obj.parent !== boardGroup) {
                    obj = obj.parent;
                }

                if (obj.userData.type === 'piece') {
                    clickedPiece = obj;
                    break;
                } else if (obj.userData.type === 'square') {
                    clickedSquare = obj;
                }
            }

            if (clickedPiece) {
                // Logic: Select only own color
                if (clickedPiece.userData.color === currentTurn) {
                    selectPiece(clickedPiece);
                } else if (clickedPiece.userData.pieceType === 'hidden') {
                    // Clicked on Hidden Opponent Piece -> Show Guess Menu
                    showGuessMenu(clickedPiece, event.clientX, event.clientY);
                } else if (selectedPiece) {
                    // Capture attempt
                    movePieceTo(selectedPiece, clickedPiece.position.x, clickedPiece.position.z);
                    boardGroup.remove(clickedPiece);
                    pieces.splice(pieces.indexOf(clickedPiece), 1);
                }
            } else if (clickedSquare && selectedPiece) {
                movePieceTo(selectedPiece, clickedSquare.position.x, clickedSquare.position.z);
            }
        }

        function showGuessMenu(piece, x, y) {
            // Remove existing menu
            const existing = document.getElementById('guess-menu');
            if (existing) existing.remove();

            const menu = document.createElement('div');
            menu.id = 'guess-menu';
            menu.style.position = 'absolute';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.background = 'rgba(30, 43, 57, 0.9)';
            menu.style.padding = '10px';
            menu.style.borderRadius = '8px';
            menu.style.border = '1px solid #00aaff';
            menu.style.display = 'grid';
            menu.style.gridTemplateColumns = 'repeat(3, 1fr)';
            menu.style.gap = '5px';
            menu.style.zIndex = '100';

            const options = ['pawn', 'rook', 'knight', 'bishop', 'queen', 'king'];
            options.forEach(type => {
                const btn = document.createElement('button');
                btn.innerText = type.charAt(0).toUpperCase() + type.slice(1);
                btn.style.background = '#00aaff';
                btn.style.color = 'white';
                btn.style.border = 'none';
                btn.style.padding = '5px';
                btn.style.cursor = 'pointer';
                btn.style.borderRadius = '4px';

                btn.onclick = () => {
                    alert(`Guessed: ${type}. Real type: ${piece.userData.realType}`);
                    menu.remove();
                };
                menu.appendChild(btn);
            });

            // Close button
            const close = document.createElement('button');
            close.innerText = 'X';
            close.style.gridColumn = '1 / -1';
            close.style.background = '#ff4444';
            close.style.color = 'white';
            close.style.border = 'none';
            close.style.marginTop = '5px';
            close.onclick = () => menu.remove();
            menu.appendChild(close);

            document.body.appendChild(menu);
        }

        function selectPiece(piece) {
            selectedPiece = piece;
            selectRing.position.x = piece.position.x;
            selectRing.position.z = piece.position.z;
            selectRing.visible = true;
        }

        function movePieceTo(piece, x, z) {
            piece.position.x = x;
            piece.position.z = z;

            selectRing.visible = false;
            selectedPiece = null;

            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            document.getElementById('status').innerText =
                currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1) + "'s Turn";
        }

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            mainGroup.position.y = Math.sin(time * 0.5) * 0.2;
            decorGroup.rotation.y = time * 0.05;

            // Animate Floating Question Marks
            pieces.forEach(p => {
                if (p.userData.pieceType === 'hidden') {
                    p.position.y = 0.1 + Math.sin(time * 2 + p.position.x) * 0.05;
                    p.rotation.y = time;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>